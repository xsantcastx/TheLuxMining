import { Component, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterLink, ActivatedRoute } from '@angular/router';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { AuthService } from '../../../services/auth.service';
import { ProductsService } from '../../../services/products.service';
import { CategoryService } from '../../../services/category.service';
import { ModelService } from '../../../services/model.service';
import { TagService } from '../../../services/tag.service';
import { StorageService } from '../../../services/storage.service';
import { MediaService } from '../../../services/media.service';
import { BenefitTemplateService } from '../../../services/benefit-template.service';
import { Product } from '../../../models/product';
import { Category, Model, Tag, TemplateComposition } from '../../../models/catalog';
import { MediaCreateInput, MEDIA_VALIDATION } from '../../../models/media';
import { BenefitTemplate } from '../../../models/benefit-template';
import { GalleryUploaderComponent } from '../../../shared/components/gallery-uploader/gallery-uploader.component';
import { AdminQuickActionsComponent } from '../../../shared/components/admin-quick-actions/admin-quick-actions.component';

interface CatalogOption {
  id: string;
  label: string;
  categoryId: string;
  modelId: string;
  familyId?: string;
  sizeHint?: string;
  isSuggestion?: boolean; // For "create new model" suggestions
}

@Component({
  selector: 'app-products-admin',
  standalone: true,
  imports: [CommonModule, RouterLink, ReactiveFormsModule, FormsModule, TranslateModule, GalleryUploaderComponent, AdminQuickActionsComponent],
  templateUrl: './products-admin.page.html',
  styleUrl: './products-admin.page.scss'
})
export class ProductsAdminComponent implements OnInit {
  private authService = inject(AuthService);
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  private fb = inject(FormBuilder);
  private productsService = inject(ProductsService);
  private categoryService = inject(CategoryService);
  private modelService = inject(ModelService);
  private tagService = inject(TagService);
  private storageService = inject(StorageService);
  private mediaService = inject(MediaService);
  private benefitTemplateService = inject(BenefitTemplateService);

  products: Product[] = [];
  categories: Category[] = [];
  models: Model[] = [];
  tags: Tag[] = [];
  benefitTemplates: BenefitTemplate[] = [];
  availableTagNames: string[] = []; // Tag names for gallery uploader

  catalogOptions: CatalogOption[] = [];
  filteredCatalogOptions: CatalogOption[] = [];
  catalogSearchTerm = '';
  selectedCatalogOption: CatalogOption | null = null;

  currentStep = 1;
  readonly maxStep = 3;
  readonly stepLabels: string[] = [
    'admin.step_select_product',
    'admin.step_content',
    'admin.step_media'
  ];

  isLoading = true;
  showModal = false;
  isEditMode = false;
  isSaving = false;
  isGenerating = false; // Loading state for template generation

  selectedProduct: Product | null = null;
  productForm: FormGroup;

  successMessage = '';
  errorMessage = '';
  searchTerm = '';
  selectedCategoryFilter = '';
  selectedModelFilter = '';
  selectedStatusFilter = '';
  showDeleteConfirm = false;
  productToDelete: Product | null = null;

  // Image upload
  selectedCoverFile: File | null = null;
  coverPreview: string | null = null;
  galleryFiles: File[] = []; // DEPRECATED - use galleryMediaIds instead
  galleryMediaIds: string[] = []; // Media document IDs for gallery images
  uploadProgress: number = 0;
  isUploading = false;

  // Auto-fill preview
  autoFillPreview: TemplateComposition | null = null;
  autoGeneratedName = ''; // Auto-generated product name from model + category
  descriptionLocked = false;
  specsLocked = false;
  seoLocked = false;
  private isAutoFilling = false;
  private currentStatus: 'draft' | 'published' | 'archived' = 'draft';
  
  // Template availability warnings
  templateWarnings: string[] = [];
  showTemplateWarning = false;

  // Tags management - no longer needed since we use dropdown
  // newTag = '';
  // suggestedTags removed - we use tags from database

  constructor() {
    this.productForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3)]],
      categoryId: ['', [Validators.required]],
      modelId: ['', [Validators.required]],
      description: [''],
      seoTitle: [''],
      seoMeta: [''],
      tags: [[] as string[]], // Array of tags
      price: ['', [Validators.min(0)]],
      stock: ['', [Validators.min(0)]],
      sku: [''],
      usage: ['Mining Farms, Data Centers'], // Comma-separated
      active: [true]
    });
  }

  async ngOnInit() {
    await this.checkAdminAccess();
    await this.loadMasterData();
    await this.loadProducts();
    this.setupAutoFillListeners();
    
    // Check if we should auto-open create modal
    this.route.queryParams.subscribe(params => {
      if (params['action'] === 'create') {
        // Wait a bit for data to load, then open modal
        setTimeout(() => {
          this.openCreateModal();
        }, 500);
      }
    });
  }

  private async checkAdminAccess() {
    const user = this.authService.getCurrentUser();
    if (!user) {
      this.router.navigate(['/client/login']);
      return;
    }

    const isAdmin = await this.authService.isAdmin(user.uid);
    if (!isAdmin) {
      this.router.navigate(['/']);
      return;
    }
  }

  private async loadMasterData() {
    try {
      // Load categories, models, tags, and benefit templates in parallel
      const [categories, models, tags, templates] = await Promise.all([
        new Promise<Category[]>((resolve) => {
          this.categoryService.getActiveCategories().subscribe({
            next: (data) => {
              console.log('‚úÖ Categories loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading categories:', err);
              resolve([]);
            }
          });
        }),
        new Promise<Model[]>((resolve) => {
          this.modelService.getActiveModels().subscribe({
            next: (data) => {
              console.log('‚úÖ Models loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading models:', err);
              resolve([]);
            }
          });
        }),
        new Promise<Tag[]>((resolve) => {
          this.tagService.getActiveTags().subscribe({
            next: (data) => {
              console.log('‚úÖ Tags loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading tags:', err);
              resolve([]);
            }
          });
        }),
        new Promise<BenefitTemplate[]>((resolve) => {
          this.benefitTemplateService.getActiveTemplates().subscribe({
            next: (data) => {
              console.log('‚úÖ Benefit templates loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading benefit templates:', err);
              resolve([]);
            }
          });
        })
      ]);

      this.categories = categories;
      this.models = models;
      this.tags = tags;
      this.benefitTemplates = templates;
      this.availableTagNames = tags.map(tag => tag.name);

      console.log('üìä Final counts - Categories:', this.categories.length, 'Models:', this.models.length, 'Tags:', this.tags.length);

      // Warn if data is missing
      if (this.categories.length === 0 || this.models.length === 0) {
        console.warn('‚ö†Ô∏è Master data not found! Please run seed at /admin/seed');
        this.errorMessage = '‚ö†Ô∏è Categories or Models not found. Please run seed first at /admin/seed';
      }

      this.buildCatalogOptions();
      this.applyCatalogFilter();
    } catch (error) {
      console.error('Error loading master data:', error);
      this.errorMessage = 'Failed to load categories/models. Please run seed first.';
    }
  }

  private async loadProducts() {
    this.isLoading = true;
    try {
      this.productsService.getAllProducts().subscribe({
        next: (products) => {
          this.products = products;
          // Debug: Check if timestamps are present
          if (products.length > 0) {
            console.log('üìÖ Product timestamps:', {
              sample: products[0].name,
              createdAt: products[0].createdAt,
              updatedAt: products[0].updatedAt
            });
          }
          this.isLoading = false;
        },
        error: (error) => {
          console.error('Error loading products:', error);
          this.errorMessage = 'admin.error_occurred';
          this.isLoading = false;
        }
      });
    } catch (error) {
      console.error('Error loading products:', error);
      this.errorMessage = 'admin.error_occurred';
      this.isLoading = false;
    }
  }

  private buildCatalogOptions() {
    const options: CatalogOption[] = [];

    this.categories.forEach((category) => {
      // Filter models that belong to this category
      const categoryModels = this.models.filter(m => m.categoryId === category.id);
      
      categoryModels.forEach((model) => {
        const id = `${category.id || category.slug}__${model.id || model.slug}`;
        const label = `${model.name} ‚Ä¢ ${category.name}`;
        const sizeHint = category.defaultSpecOverrides?.size;

        options.push({
          id,
          label,
          categoryId: category.id || category.slug,
          modelId: model.id || model.slug,
          sizeHint
        });
      });
      
      // Add suggestion for creating new models in this category
      if (categoryModels.length === 0) {
        options.push({
          id: `suggestion_${category.id}`,
          label: `‚ûï Create new model in ${category.name}`,
          categoryId: category.id || category.slug,
          modelId: '',
          sizeHint: undefined,
          isSuggestion: true
        });
      }
    });

    this.catalogOptions = options.sort((a, b) => a.label.localeCompare(b.label));
    console.log('Built catalog options:', this.catalogOptions.length);
  }

  applyCatalogFilter(term: string = this.catalogSearchTerm) {
    const normalized = term.trim().toLowerCase();
    if (!normalized) {
      this.filteredCatalogOptions = [...this.catalogOptions];
      console.log('Showing all catalog options:', this.filteredCatalogOptions.length);
      return;
    }

    this.filteredCatalogOptions = this.catalogOptions.filter(option =>
      option.label.toLowerCase().includes(normalized)
    );
    console.log(`Filtered to ${this.filteredCatalogOptions.length} options for term: "${term}"`);
  }

  onCatalogSearch(value: string) {
    this.catalogSearchTerm = value;
    this.applyCatalogFilter(value);
  }

  selectCatalogOption(option: CatalogOption) {
    if (!option) {
      return;
    }
    
    // If it's a suggestion to create new model, navigate to catalog
    if (option.isSuggestion) {
      this.router.navigate(['/admin/catalog'], { 
        queryParams: { 
          tab: 'models',
          categoryId: option.categoryId 
        } 
      });
      return;
    }
    
    this.selectedCatalogOption = option;

    this.productForm.patchValue({
      categoryId: option.categoryId,
      modelId: option.modelId,
      size: option.sizeHint || this.productForm.get('size')?.value
    });

    this.updateAutoGeneratedName();
    this.autoLoadTemplateData();
    this.goToStep(2);
  }

  goToStep(step: number) {
    if (step < 1 || step > this.maxStep) {
      return;
    }

    // Allow backward navigation without validation, or forward navigation with validation
    // In edit mode, always allow navigation since data is already loaded
    if (step > this.currentStep && !this.isEditMode && !this.isStepValid(this.currentStep)) {
      this.errorMessage = 'admin.invalid_form';
      return;
    }

    this.currentStep = step;
    this.errorMessage = ''; // Clear any previous error messages
  }

  nextStep() {
    this.goToStep(this.currentStep + 1);
  }

  previousStep() {
    this.goToStep(this.currentStep - 1);
  }

  private isStepValid(step: number): boolean {
    if (step === 1) {
      const categoryId = this.productForm.get('categoryId')?.value;
      const modelId = this.productForm.get('modelId')?.value;
      if (!categoryId || !modelId) {
        return false;
      }
    }

    if (step === 2) {
      if (this.productForm.get('name')?.invalid) {
        return false;
      }
    }

    return true;
  }

  /**
   * Setup form listeners for auto-fill functionality
   */
  private setupAutoFillListeners() {
    // Watch for changes in categoryId or modelId to auto-generate product name
    this.productForm.get('categoryId')?.valueChanges.subscribe(() => {
      this.updateAutoGeneratedName();
      this.autoLoadTemplateData();
    });
    this.productForm.get('modelId')?.valueChanges.subscribe(() => {
      this.updateAutoGeneratedName();
      this.autoLoadTemplateData();
    });
    
    // Watch for name selection changes to trigger auto-fill
    this.productForm.get('name')?.valueChanges.subscribe(() => {
      this.autoLoadTemplateData();
    });

    // Lock fields when user manually edits them (prevents auto-updates)
    // But only if we're not in the middle of auto-filling or resetting the form
    this.productForm.get('description')?.valueChanges.subscribe((value) => {
      if (!this.isAutoFilling && value && value.trim() !== '') {
        // User typed something, lock to prevent overwrites
        this.descriptionLocked = true;
      }
    });

    this.productForm.get('seoTitle')?.valueChanges.subscribe((value) => {
      if (!this.isAutoFilling && value && value.trim() !== '') {
        this.seoLocked = true;
      }
    });

    this.productForm.get('seoMeta')?.valueChanges.subscribe((value) => {
      if (!this.isAutoFilling && value && value.trim() !== '') {
        this.seoLocked = true;
      }
    });
  }

  /**
   * Update auto-generated product name when material or category changes
   */
  private updateAutoGeneratedName() {
    const categoryId = this.productForm.get('categoryId')?.value;
    const modelId = this.productForm.get('modelId')?.value;

    if (!categoryId || !modelId) {
      this.autoGeneratedName = '';
      this.productForm.patchValue({ name: '' }, { emitEvent: false });
      return;
    }

    const category = this.categories.find(c => c.id === categoryId);
    const model = this.models.find(m => m.id === modelId);

    if (category && model) {
      if (this.selectedCatalogOption) {
        this.autoGeneratedName = this.selectedCatalogOption.label.replace(' ‚Ä¢ ', ' ');
      } else {
        // Generate name: "{Model} {Grosor}" (e.g., "Black Gold 12mm")
        this.autoGeneratedName = `${model.name} ${category.slug}`;
      }
      // Update form value silently (without triggering valueChanges)
      this.isAutoFilling = true;
      this.productForm.patchValue({ name: this.autoGeneratedName }, { emitEvent: false });
      this.isAutoFilling = false;
    }
  }

  /**
   * Trigger auto-fill when name, category, or material changes
   */
  async triggerAutoFill() {
    const name = this.productForm.get('name')?.value;
    const categoryId = this.productForm.get('categoryId')?.value;
    const modelId = this.productForm.get('modelId')?.value;

    // Reset warnings
    this.templateWarnings = [];
    this.showTemplateWarning = false;

    // Need all three to generate
    if (!name || !categoryId || !modelId) {
      this.autoFillPreview = null;
      return;
    }

    this.isGenerating = true;
    const previousAuto = this.isAutoFilling;
    this.isAutoFilling = true;

    try {
      // Get usage from form
      const usageStr = this.productForm.get('usage')?.value || '';
      const usage = usageStr ? usageStr.split(',').map((u: string) => u.trim()) : [];

      // Generate auto-filled data
      const generated = await this.productsService.generateProductData({
        name,
        categoryId,
        modelId,
        usage,
        finish: this.productForm.get('finish')?.value
      } as any);

      this.autoFillPreview = generated;

      // Check for missing templates and add warnings
      if (!generated.description || generated.description.trim() === '') {
        this.templateWarnings.push('Description template not found - using default');
      }
      if (!generated.seoTitle || generated.seoTitle.trim() === '') {
        this.templateWarnings.push('SEO title template not found - using default');
      }
      if (!generated.seoMeta || generated.seoMeta.trim() === '') {
        this.templateWarnings.push('SEO meta description template not found - using default');
      }

      // Show warning if any templates are missing
      if (this.templateWarnings.length > 0) {
        this.showTemplateWarning = true;
      }

      // Auto-apply if not locked
      if (!this.descriptionLocked && generated.description) {
        this.productForm.patchValue({ description: generated.description }, { emitEvent: false });
      }
      if (!this.seoLocked) {
        if (generated.seoTitle) {
          this.productForm.patchValue({ seoTitle: generated.seoTitle }, { emitEvent: false });
        }
        if (generated.seoMeta) {
          this.productForm.patchValue({ seoMeta: generated.seoMeta }, { emitEvent: false });
        }
      }

    } catch (error) {
      console.error('Error generating auto-fill:', error);
      this.templateWarnings.push('Error loading templates - please check your configuration');
      this.showTemplateWarning = true;
    } finally {
      this.isGenerating = false;
      this.isAutoFilling = previousAuto;
    }
  }

  /**
   * Toggle description lock
   */
  toggleDescriptionLock() {
    this.descriptionLocked = !this.descriptionLocked;
  }

  /**
   * Toggle specs lock
   */
  toggleSpecsLock() {
    this.specsLocked = !this.specsLocked;
  }

  /**
   * Toggle SEO lock
   */
  toggleSeoLock() {
    this.seoLocked = !this.seoLocked;
  }

  // =========== SPECS MANAGEMENT ===========
  
  newSpecKey = '';
  newSpecValue = '';
  currentSpecs: Record<string, any> = {};

  /**
   * Get current specs as array for display
   */
  getCurrentSpecs(): Array<{key: string, value: any}> {
    if (!this.currentSpecs || Object.keys(this.currentSpecs).length === 0) {
      return [];
    }
    return Object.entries(this.currentSpecs).map(([key, value]) => ({ key, value }));
  }

  /**
   * Add a new spec
   */
  addSpec() {
    if (!this.newSpecKey || !this.newSpecValue) return;
    
    const key = this.newSpecKey.trim();
    const value = this.newSpecValue.trim();
    
    if (key && value) {
      this.currentSpecs[key] = value;
      this.newSpecKey = '';
      this.newSpecValue = '';
    }
  }

  /**
   * Remove a spec
   */
  removeSpec(key: string) {
    delete this.currentSpecs[key];
  }

  /**
   * Format spec label for display
   */
  formatSpecLabel(key: string): string {
    // Convert camelCase to Title Case
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }

  /**
   * Apply a spec template
   */
  applySpecTemplate(template: { key: string; label: string; placeholder: string }) {
    this.newSpecKey = template.key;
    this.newSpecValue = '';
  }

  /**
   * Get mining spec templates
   */
  getMiningSpecTemplates() {
    return [
      { key: 'hashRate', label: 'Hash Rate', placeholder: '110 TH/s' },
      { key: 'powerConsumption', label: 'Power', placeholder: '3250W' },
      { key: 'efficiency', label: 'Efficiency', placeholder: '29.5 J/TH' },
      { key: 'algorithm', label: 'Algorithm', placeholder: 'SHA-256' },
      { key: 'chipType', label: 'Chip Type', placeholder: '7nm ASIC' },
      { key: 'cooling', label: 'Cooling', placeholder: 'Dual Fan System' },
      { key: 'dimensions', label: 'Dimensions', placeholder: '370√ó195√ó290mm' },
      { key: 'weight', label: 'Weight', placeholder: '13.2 kg' },
      { key: 'temperature', label: 'Temperature', placeholder: '0-40¬∞C' },
      { key: 'network', label: 'Network', placeholder: 'Ethernet' },
      { key: 'voltage', label: 'Voltage', placeholder: '220V' },
      { key: 'warranty', label: 'Warranty', placeholder: '180 days' },
      { key: 'noiseLevel', label: 'Noise Level', placeholder: '75 dB' },
    ];
  }

  /**
   * Get accessory spec templates
   */
  getAccessorySpecTemplates() {
    return [
      { key: 'material', label: 'Material', placeholder: 'Stainless Steel' },
      { key: 'dimensions', label: 'Dimensions', placeholder: '5cm √ó 2cm' },
      { key: 'weight', label: 'Weight', placeholder: '15g' },
      { key: 'finish', label: 'Finish', placeholder: 'Polished Chrome' },
      { key: 'color', label: 'Color', placeholder: 'Silver' },
      { key: 'packaging', label: 'Packaging', placeholder: 'Gift Box Included' },
    ];
  }

  /**
   * Get wallet spec templates
   */
  getWalletSpecTemplates() {
    return [
      { key: 'screenSize', label: 'Screen Size', placeholder: '128√ó64 pixels' },
      { key: 'connectivity', label: 'Connectivity', placeholder: 'USB-C, Bluetooth' },
      { key: 'compatibility', label: 'Compatibility', placeholder: 'Windows, macOS, Linux, Android, iOS' },
      { key: 'supportedCoins', label: 'Supported Coins', placeholder: '5500+ cryptocurrencies' },
      { key: 'securityChip', label: 'Security Chip', placeholder: 'CC EAL5+ certified' },
      { key: 'battery', label: 'Battery', placeholder: 'Rechargeable Li-ion' },
      { key: 'dimensions', label: 'Dimensions', placeholder: '62.39mm √ó 17.4mm √ó 8.24mm' },
      { key: 'weight', label: 'Weight', placeholder: '34g' },
      { key: 'certifications', label: 'Certifications', placeholder: 'CE, FCC' },
    ];
  }

  // =========== BENEFITS MANAGEMENT ===========
  
  currentBenefits: any[] = [];

  /**
   * Add a benefit
   */
  addBenefit(template: any) {
    if (this.currentBenefits.length >= 4) return;
    this.currentBenefits.push({ ...template });
  }

  /**
   * Remove a benefit
   */
  removeBenefit(index: number) {
    this.currentBenefits.splice(index, 1);
  }

  /**
   * Get SVG path for benefit icon
   */
  getBenefitIconPath(iconType: string): string {
    const iconPaths: Record<string, string> = {
      'performance': 'M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z',
      'efficiency': 'M13 10V3L4 14h7v7l9-11h-7z',
      'reliability': 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
      'support': 'M18.364 5.636l-3.536 3.536m0 5.656l3.536 3.536M9.172 9.172L5.636 5.636m3.536 9.192l-3.536 3.536M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-5 0a4 4 0 11-8 0 4 4 0 018 0z',
      'quality': 'M5 13l4 4L19 7',
      'security': 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z',
      'warranty': 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z',
      'design': 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z',
      'value': 'M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
    };
    return iconPaths[iconType] || iconPaths['performance'];
  }

  /**
   * Get mining benefit templates from database
   */
  getMiningBenefitTemplates() {
    return this.benefitTemplates
      .filter(t => t.category === 'mining' || t.category === 'general')
      .map(t => ({
        icon: t.icon,
        iconColor: t.iconColor,
        title: t.title,
        description: t.description
      }));
  }

  /**
   * Get accessory benefit templates from database
   */
  getAccessoryBenefitTemplates() {
    return this.benefitTemplates
      .filter(t => t.category === 'accessory' || t.category === 'general')
      .map(t => ({
        icon: t.icon,
        iconColor: t.iconColor,
        title: t.title,
        description: t.description
      }));
  }

  /**
   * Get wallet benefit templates from database
   */
  getWalletBenefitTemplates() {
    return this.benefitTemplates
      .filter(t => t.category === 'wallet' || t.category === 'general')
      .map(t => ({
        icon: t.icon,
        iconColor: t.iconColor,
        title: t.title,
        description: t.description
      }));
  }

  get filteredProducts(): Product[] {
    let filtered = this.products;

    // Filter by search term
    if (this.searchTerm) {
      const term = this.searchTerm.toLowerCase();
      filtered = filtered.filter(p => 
        p.name.toLowerCase().includes(term) ||
        p.slug.toLowerCase().includes(term) ||
        (p.description && p.description.toLowerCase().includes(term))
      );
    }

    // Filter by category
    if (this.selectedCategoryFilter) {
      filtered = filtered.filter(p => p.categoryId === this.selectedCategoryFilter);
    }

    // Filter by model
    if (this.selectedModelFilter) {
      filtered = filtered.filter(p => p.modelId === this.selectedModelFilter);
    }

    // Filter by status
    if (this.selectedStatusFilter) {
      filtered = filtered.filter(p => p.status === this.selectedStatusFilter);
    }

    return filtered;
  }

  openCreateModal() {
    this.isEditMode = false;
    this.selectedProduct = null;
    this.autoFillPreview = null;
    this.isAutoFilling = true; // Prevent locks during reset
    this.descriptionLocked = false;
    this.seoLocked = false;
    this.currentStatus = 'draft';
    this.selectedCatalogOption = null;
    this.catalogSearchTerm = '';
    this.applyCatalogFilter('');
    this.currentStep = 1;
    
    // Reset specs
    this.currentSpecs = {};
    this.newSpecKey = '';
    this.newSpecValue = '';
    
    // Reset benefits
    this.currentBenefits = [];
    
    this.productForm.reset({ 
      name: '',
      categoryId: '',
      materialId: '',
      description: '',
      seoTitle: '',
      seoMeta: '',
      size: '160√ó320cm',
      finish: 'Pulido',
      usage: '',
      active: true
    }, { emitEvent: false }); // Don't trigger valueChanges listeners
    
    this.selectedCoverFile = null;
    this.coverPreview = null;
    this.galleryFiles = [];
    this.showModal = true;
    this.successMessage = '';
    this.errorMessage = '';
    
    // Reset auto-filling flag after a short delay
    setTimeout(() => {
      this.isAutoFilling = false;
    }, 100);
  }

  async openEditModal(product: any) {
    console.log('üìù Opening edit modal for product:');
    console.log('   - ID:', product.id);
    console.log('   - Name:', product.name);
    console.log('   - Slug:', product.slug);
    console.log('   - Full product object:', product);
    
    this.isEditMode = true;
    this.selectedProduct = product;
    this.autoFillPreview = null;
    
    // Load lock states from product data (default to true if editing to preserve existing content)
    this.descriptionLocked = product.descriptionLocked !== undefined ? product.descriptionLocked : true;
    this.specsLocked = product.specsLocked !== undefined ? product.specsLocked : false;
    this.seoLocked = product.seoLocked !== undefined ? product.seoLocked : true;
    
    this.currentStatus = product.status || 'draft';
    this.currentStep = 2; // Start at step 2 (content) in edit mode
    
    // Load specs into currentSpecs
    this.currentSpecs = product.specs ? { ...product.specs } : {};
    
    // Load benefits
    this.currentBenefits = product.benefits ? [...product.benefits] : [];
    
    const usageStr = product.specs?.usage?.join(', ') || '';
    
    this.productForm.patchValue({
      name: product.name,
      categoryId: product.categoryId || '',
      modelId: product.modelId || '',
      description: product.description || '',
      seoTitle: product.seo?.title || '',
      seoMeta: product.seo?.metaDescription || '',
      tags: product.tags || [],
      price: product.price || '',
      stock: product.stock || '',
      size: product.specs?.size || product.size || '160√ó320cm',
      sku: product.sku || '',
      finish: product.specs?.finish || 'Pulido',
      usage: usageStr,
      active: product.active !== false
    });
    
    this.selectedCoverFile = null;
    
    // Resolve cover image URL
    // If coverImage looks like a Media ID (no http/https), fetch the actual URL
    let coverImageUrl = '';
    if (product.coverImage) {
      if (product.coverImage.startsWith('http')) {
        // It's already a URL
        coverImageUrl = product.coverImage;
      } else {
        // It's a Media ID, fetch the media object to get the URL
        try {
          const media = await this.mediaService.getMediaById(product.coverImage);
          coverImageUrl = media?.url || '';
          console.log('Resolved coverImage from Media ID:', { mediaId: product.coverImage, url: coverImageUrl });
        } catch (error) {
          console.error('Error fetching media for coverImage:', error);
        }
      }
    }
    
    // Fallback to imageUrl if coverImage resolution failed
    if (!coverImageUrl && product.imageUrl) {
      coverImageUrl = product.imageUrl;
    }
    
    this.coverPreview = coverImageUrl;
    
    // Debug log to check what we're getting
    console.log('Edit Mode - Product Image Data:', {
      productId: product.id,
      productName: product.name,
      coverImage: product.coverImage,
      imageUrl: product.imageUrl,
      resolvedCoverImageUrl: coverImageUrl,
      finalCoverPreview: this.coverPreview
    });
    
    this.galleryFiles = [];
    this.galleryMediaIds = product.galleryImageIds || [];
    this.showModal = true;
    this.successMessage = '';
    this.errorMessage = '';
  }

  closeModal() {
    this.showModal = false;
    this.productForm.reset();
    this.selectedProduct = null;
    if (this.coverPreview && this.coverPreview.startsWith('blob:')) {
      URL.revokeObjectURL(this.coverPreview);
    }
    this.selectedCoverFile = null;
    this.coverPreview = null;
    this.galleryFiles = [];
    this.galleryMediaIds = [];
    this.uploadProgress = 0;
    this.autoFillPreview = null;
    this.descriptionLocked = false;
    this.specsLocked = false;
    this.seoLocked = false;
    this.currentStep = 1;
  }

  async onCoverSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) {
      return;
    }

    const file = input.files[0];

    // Validate file type
    const validation = this.storageService.validateImageFile(file);
    if (!validation.valid) {
      this.errorMessage = validation.error || 'Invalid file';
      return;
    }

    // Validate file size
    if (file.size > MEDIA_VALIDATION.MAX_SIZE) {
      this.errorMessage = `File is too large. Maximum size is ${MEDIA_VALIDATION.MAX_SIZE / 1024 / 1024}MB`;
      return;
    }

    // Get image dimensions
    let dimensions: { width: number; height: number };
    try {
      dimensions = await this.mediaService.getImageDimensions(file);
    } catch (error) {
      console.error('Error getting image dimensions:', error);
      this.errorMessage = 'Failed to load image. Please try another file.';
      return;
    }

    // Validate image dimensions
    if (dimensions.width < MEDIA_VALIDATION.MIN_WIDTH || dimensions.height < MEDIA_VALIDATION.MIN_HEIGHT) {
      this.errorMessage = `Image is too small: ${dimensions.width}x${dimensions.height}px. Minimum required: ${MEDIA_VALIDATION.MIN_WIDTH}x${MEDIA_VALIDATION.MIN_HEIGHT}px`;
      return;
    }

    this.selectedCoverFile = file;
    this.errorMessage = '';

    if (this.coverPreview && this.coverPreview.startsWith('blob:')) {
      URL.revokeObjectURL(this.coverPreview);
    }

    this.coverPreview = URL.createObjectURL(file);
    console.log(`‚úÖ Cover image selected: ${dimensions.width}x${dimensions.height}px`);
  }

  onGalleryFilesSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) {
      return;
    }

    const files = Array.from(input.files);
    const accepted: File[] = [];

    for (const file of files) {
      const validation = this.storageService.validateImageFile(file);
      if (!validation.valid) {
        this.errorMessage = validation.error || 'Invalid file';
        continue;
      }
      accepted.push(file);
    }

    if (accepted.length) {
      this.galleryFiles = [...this.galleryFiles, ...accepted];
      this.errorMessage = '';
    }
  }

  removeGalleryFile(index: number) {
    if (index < 0 || index >= this.galleryFiles.length) {
      return;
    }
    this.galleryFiles = this.galleryFiles.filter((_, i) => i !== index);
  }

  // Handle gallery media IDs from GalleryUploaderComponent
  onGalleryMediaIdsChange(mediaIds: string[]) {
    this.galleryMediaIds = mediaIds;
    console.log('‚úÖ Gallery media IDs updated:', mediaIds.length);
  }

  // Get current product slug for gallery uploader
  get currentProductSlug(): string {
    const formData = this.productForm.value;
    const category = this.categories.find(c => c.id === formData.categoryId);
    const grosor = category?.slug || '12mm';
    return this.getProductSlug(formData.name, grosor);
  }

  // Get current product grosor for gallery uploader
  get currentProductGrosor(): string {
    const formData = this.productForm.value;
    const category = this.categories.find(c => c.id === formData.categoryId);
    return category?.slug || '12mm';
  }

  async saveDraft() {
    await this.saveProduct('draft');
  }

  async publishProduct() {
    await this.saveProduct('published');
  }

  private async saveProduct(status: 'draft' | 'published') {
    // For drafts, only require basic product info (name, category, model)
    // For published, validate all required fields
    const formData = this.productForm.value;
    
    if (status === 'draft') {
      // Drafts require minimal validation
      if (!formData.name || formData.name.trim().length < 3) {
        this.errorMessage = 'Product name is required (minimum 3 characters)';
        return;
      }
      if (!formData.categoryId) {
        this.errorMessage = 'Please select a category';
        return;
      }
      if (!formData.modelId) {
        this.errorMessage = 'Please select a model';
        return;
      }
    } else if (status === 'published') {
      // Published products need all required fields
      if (this.productForm.invalid) {
        this.markFormGroupTouched(this.productForm);
        this.errorMessage = 'admin.invalid_form';
        return;
      }
      
      if (!this.canPublish) {
        const blockers = this.getPublishBlockers();
        this.errorMessage = `Cannot publish. Missing: ${blockers.join(', ')}`;
        return;
      }
    }

    this.isSaving = true;
    this.errorMessage = '';
    this.uploadProgress = 0;

    try {
      const category = this.categories.find(c => c.id === formData.categoryId);
      const grosor = category?.slug || '12mm';

      const slug = this.getProductSlug(formData.name, grosor);

      // Check slug duplicates only when creating or if the slug has actually changed
      const slugChanged = this.isEditMode && this.selectedProduct 
        ? slug !== this.selectedProduct.slug 
        : true; // Always check for new products
      
      console.log('üîç Slug validation:', {
        isEditMode: this.isEditMode,
        selectedProductId: this.selectedProduct?.id,
        oldSlug: this.selectedProduct?.slug,
        newSlug: slug,
        slugChanged,
        willCheckDuplicate: slugChanged
      });
      
      if (slugChanged) {
        console.log('üîé Calling slugExists with:');
        console.log('  - slug:', slug);
        console.log('  - grosor:', grosor);
        console.log('  - excludeId:', this.selectedProduct?.id);
        const slugExists = await this.productsService.slugExists(
          slug,
          grosor,
          this.selectedProduct?.id
        );
        console.log('üìã Slug exists check result:', slugExists);
        if (slugExists) {
          this.errorMessage = 'admin.duplicate_slug';
          this.isSaving = false;
          return;
        }
      }

      const existingCover = this.selectedProduct?.coverImage || (this.selectedProduct as any)?.imageUrl;
      let coverImage = existingCover || '';
      let coverImageUrl = this.selectedProduct?.imageUrl || '';
      
      if (this.selectedCoverFile) {
        const uploadResult = await this.uploadCoverImage(slug, grosor, existingCover);
        coverImage = uploadResult.mediaId;
        coverImageUrl = uploadResult.url;
      }

      const usage = formData.usage
        ? formData.usage.split(',').map((u: string) => u.trim()).filter((u: string) => u.length > 0)
        : [];

      const productData: any = {
        name: formData.name,
        slug,
        categoryId: formData.categoryId,
        modelId: formData.modelId,
        status,
        description: formData.description || '',
        variantMode: 'embedded',
        variants: [{
          sku: formData.sku || undefined,
          finish: formData.finish || 'Pulido',
          price: formData.price ? parseFloat(formData.price) : null,
          stock: formData.stock ? parseInt(formData.stock) : 0,
          active: status === 'published'
        }],
        coverImage,
        galleryImageIds: this.galleryMediaIds.length > 0 ? this.galleryMediaIds : (this.selectedProduct?.galleryImageIds || []),
        specs: {
          grosor,
          size: formData.size,
          finish: formData.finish,
          thicknessMm: category?.defaultSpecOverrides?.thicknessMm,
          usage,
          ...this.currentSpecs // Merge in the dynamic specs
        },
        seo: {
          title: formData.seoTitle || '',
          metaDescription: formData.seoMeta || '',
          ogImage: coverImageUrl || undefined
        },
        tags: formData.tags || [],
        benefits: this.currentBenefits.length > 0 ? this.currentBenefits : undefined,
        descriptionLocked: this.descriptionLocked,
        specsLocked: this.specsLocked,
        seoLocked: this.seoLocked,
        // Compatibility fields
        grosor,
        size: formData.size,
        imageUrl: coverImageUrl, // Use the actual download URL, not Media ID
        price: formData.price ? parseFloat(formData.price) : undefined,
        stock: formData.stock ? parseInt(formData.stock) : undefined,
        sku: formData.sku || undefined,
        active: status === 'published'
      };

      if (this.isEditMode && this.selectedProduct?.id) {
        await this.productsService.updateProduct(this.selectedProduct.id, productData);
        
        // Update media with product reference if cover was uploaded
        if (coverImage && coverImage !== existingCover) {
          await this.mediaService.addEntityReference(coverImage, 'product', this.selectedProduct.id);
        }
        
        this.successMessage = status === 'published' ? 'admin.product_published' : 'admin.saved_successfully';
        this.currentStatus = status;
      } else {
        const productId = await this.productsService.addProduct(productData);
        
        // Update media with product reference if cover was uploaded
        if (coverImage && productId) {
          await this.mediaService.addEntityReference(coverImage, 'product', productId);
        }
        
        this.successMessage = status === 'published' ? 'admin.product_published' : 'admin.saved_successfully';
        this.currentStatus = status;
      }

      await this.loadProducts();
      this.closeModal();

      setTimeout(() => {
        this.successMessage = '';
      }, 3000);
    } catch (error) {
      console.error('Error saving product:', error);
      this.errorMessage = 'admin.error_occurred';
    } finally {
      this.isSaving = false;
      this.isUploading = false;
      this.uploadProgress = 0;
    }
  }

  private getProductSlug(name: string, grosor: string): string {
    const baseSlug = this.storageService.generateSlug(name);
    if (this.isEditMode && this.selectedProduct?.slug === baseSlug) {
      return baseSlug;
    }
    return baseSlug;
  }

  private async uploadCoverImage(slug: string, grosor: string, existingCover?: string | null): Promise<{ mediaId: string; url: string }> {
    if (!this.selectedCoverFile) {
      return { mediaId: existingCover || '', url: existingCover || '' };
    }

    this.isUploading = true;

    try {
      // Get current user
      const user = await this.authService.getCurrentUser();
      if (!user) {
        throw new Error('User not authenticated');
      }

      // Get image dimensions
      const dimensions = await this.mediaService.getImageDimensions(this.selectedCoverFile);

      // Delete old cover if exists (only if it's a Media ID)
      if (this.isEditMode && existingCover && !existingCover.startsWith('http')) {
        try {
          await this.mediaService.deleteMedia(existingCover);
        } catch (error) {
          console.warn('Could not delete old media:', error);
        }
      }

      // Upload image to Storage
      const downloadURL = await new Promise<string>((resolve, reject) => {
        this.storageService.uploadProductImage(
          this.selectedCoverFile!,
          slug,
          grosor
        ).subscribe({
          next: (progress) => {
            this.uploadProgress = progress.progress;
            if (progress.downloadURL) {
              resolve(progress.downloadURL);
            }
          },
          error: (error) => {
            reject(error);
          }
        });
      });

      // Extract storage path from URL for future deletion
      const storagePath = `productos/${grosor}/${slug}/${this.selectedCoverFile.name}`;

      // Create Media document
      const mediaInput: MediaCreateInput = {
        url: downloadURL,
        filename: this.selectedCoverFile.name,
        storagePath: storagePath,
        width: dimensions.width,
        height: dimensions.height,
        size: this.selectedCoverFile.size,
        mimeType: this.selectedCoverFile.type,
        uploadedBy: user.uid,
        tags: ['cover', 'product'],
        relatedEntityType: 'product',
        relatedEntityIds: [], // Will be updated when product is saved
      };

      const mediaId = await this.mediaService.createMedia(mediaInput);
      console.log('‚úÖ Media document created:', mediaId);

      this.isUploading = false;
      this.selectedCoverFile = null;

      // Return both media ID and download URL
      return { mediaId, url: downloadURL };

    } catch (error) {
      this.isUploading = false;
      console.error('‚ùå Error uploading cover image:', error);
      throw error;
    }
  }

  openDeleteConfirm(product: Product) {
    this.productToDelete = product;
    this.showDeleteConfirm = true;
  }

  closeDeleteConfirm() {
    this.showDeleteConfirm = false;
    this.productToDelete = null;
  }

  async confirmDelete() {
    if (!this.productToDelete || !this.productToDelete.id) return;

    try {
      // Delete image from storage
      if (this.productToDelete.imageUrl) {
        try {
          await this.storageService.deleteFile(this.productToDelete.imageUrl);
        } catch (error) {
          console.warn('Could not delete image:', error);
        }
      }

      // Delete product from Firestore
      await this.productsService.deleteProduct(this.productToDelete.id);
      
      this.successMessage = 'admin.deleted_successfully';
      this.closeDeleteConfirm();
      await this.loadProducts();

      setTimeout(() => {
        this.successMessage = '';
      }, 3000);
    } catch (error) {
      console.error('Error deleting product:', error);
      this.errorMessage = 'admin.error_occurred';
    }
  }

  async logout() {
    try {
      await this.authService.signOutUser();
      this.router.navigate(['/']);
    } catch (error) {
      console.error('Logout error:', error);
    }
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.keys(formGroup.controls).forEach(key => {
      const control = formGroup.get(key);
      control?.markAsTouched();
    });
  }

  // Form getters
  get name() { return this.productForm.get('name'); }
  get categoryId() { return this.productForm.get('categoryId'); }
  get materialId() { return this.productForm.get('materialId'); }
  get description() { return this.productForm.get('description'); }
  get seoTitle() { return this.productForm.get('seoTitle'); }
  get seoMeta() { return this.productForm.get('seoMeta'); }
  get price() { return this.productForm.get('price'); }
  get stock() { return this.productForm.get('stock'); }
  get size() { return this.productForm.get('size'); }
  get sku() { return this.productForm.get('sku'); }
  get finish() { return this.productForm.get('finish'); }
  get usage() { return this.productForm.get('usage'); }
  get active() { return this.productForm.get('active'); }
  get hasCoverImage(): boolean {
    return !!this.selectedCoverFile || !!this.coverPreview || !!this.selectedProduct?.coverImage;
  }

  canAdvance(): boolean {
    return this.isStepValid(this.currentStep);
  }

  /**
   * Check if product can be published
   * Returns true only if all required fields are present
   */
  get canPublish(): boolean {
    const formData = this.productForm.value;
    
    // Required: name (min 3 chars)
    const hasName = formData.name && formData.name.trim().length >= 3;
    
    // Required: category and model selected
    const hasCategory = !!formData.categoryId;
    const hasModel = !!formData.modelId;
    
    // Required: cover image (either new file selected or existing)
    const hasCover = this.hasCoverImage;
    
    // Required: at least one gallery image
    const hasGallery = this.galleryMediaIds.length > 0 || (this.selectedProduct?.galleryImageIds?.length || 0) > 0;
    
    // All validations must pass
    return hasName && hasCategory && hasModel && hasCover && hasGallery;
  }

  /**
   * Get list of missing requirements for publishing
   * Returns array of user-friendly messages
   */
  getPublishBlockers(): string[] {
    const blockers: string[] = [];
    const formData = this.productForm.value;
    
    if (!formData.name || formData.name.trim().length < 3) {
      blockers.push('Product name (minimum 3 characters)');
    }
    
    if (!formData.categoryId) {
      blockers.push('Category selection');
    }
    
    if (!formData.modelId) {
      blockers.push('Model selection');
    }
    
    if (!this.hasCoverImage) {
      blockers.push('Cover image');
    }
    
    const hasGallery = this.galleryMediaIds.length > 0 || (this.selectedProduct?.galleryImageIds?.length || 0) > 0;
    if (!hasGallery) {
      blockers.push('At least one gallery image');
    }
    
    return blockers;
  }

  /**
   * Get category name by ID
   */
  getCategoryName(categoryId: string | undefined): string {
    if (!categoryId) return 'Unknown';
    const category = this.categories.find(c => c.id === categoryId);
    return category?.name || 'Unknown';
  }

  /**
   * Get material name by ID
   */
  getModelName(modelId: string | undefined): string {
    if (!modelId) return 'Unknown';
    const model = this.models.find(m => m.id === modelId);
    return model?.name || 'Unknown';
  }

  getSelectedCategoryName(): string {
    const categoryId = this.productForm.get('categoryId')?.value;
    return this.getCategoryName(categoryId);
  }

  getSelectedModelName(): string {
    const modelId = this.productForm.get('modelId')?.value;
    return this.getModelName(modelId);
  }

  /**
   * Filter models by selected category
   */
  get filteredModelsByCategory(): Model[] {
    const categoryId = this.productForm.get('categoryId')?.value;
    if (!categoryId) return [];
    
    return this.models.filter(m => m.categoryId === categoryId);
  }

  /**
   * Handle category change - clear model selection and reload templates
   */
  onCategoryChange() {
    this.productForm.patchValue({ modelId: '' });
    // Auto-load template data when both category and model are selected
    const modelId = this.productForm.get('modelId')?.value;
    if (modelId) {
      this.autoLoadTemplateData();
    }
  }

  /**
   * Handle model change - reload templates
   */
  onModelChange() {
    this.autoLoadTemplateData();
  }

  /**
   * Auto-load template data from category and model
   */
  async autoLoadTemplateData() {
    const categoryId = this.productForm.get('categoryId')?.value;
    const modelId = this.productForm.get('modelId')?.value;
    const name = this.productForm.get('name')?.value;

    console.log('üîÑ Auto-load triggered:', { categoryId, modelId, name, descriptionLocked: this.descriptionLocked, seoLocked: this.seoLocked });

    // Need at least category and model
    if (!categoryId || !modelId) {
      console.log('‚è≠Ô∏è Skipping auto-load: missing category or model');
      return;
    }

    this.isGenerating = true;
    this.templateWarnings = [];
    this.showTemplateWarning = false;
    this.isAutoFilling = true; // Prevent lock state changes during auto-fill

    try {
      console.log('üì° Fetching template data...');
      
      // Generate template data
      const generated = await this.productsService.generateProductData({
        name: name || 'Product',
        categoryId,
        modelId,
        usage: [],
        finish: this.productForm.get('finish')?.value
      } as any);

      console.log('üì¶ Generated data:', generated);
      this.autoFillPreview = generated;

      // Auto-apply to unlocked fields
      if (!this.descriptionLocked && generated.description) {
        console.log('‚úçÔ∏è Applying description (unlocked)');
        this.productForm.patchValue({ description: generated.description }, { emitEvent: false });
      } else {
        console.log('üîí Description locked, not updating');
      }
      
      if (!this.seoLocked) {
        if (generated.seoTitle) {
          console.log('‚úçÔ∏è Applying SEO title (unlocked)');
          this.productForm.patchValue({ seoTitle: generated.seoTitle }, { emitEvent: false });
        }
        if (generated.seoMeta) {
          console.log('‚úçÔ∏è Applying SEO meta (unlocked)');
          this.productForm.patchValue({ seoMeta: generated.seoMeta }, { emitEvent: false });
        }
      } else {
        console.log('üîí SEO locked, not updating');
      }

      console.log('‚úÖ Auto-loaded templates successfully');

    } catch (error) {
      console.error('‚ùå Error auto-loading templates:', error);
    } finally {
      this.isGenerating = false;
      this.isAutoFilling = false;
    }
  }

  /**
   * Get product name suggestions based on category and model
   */
  getProductSuggestions(): string[] {
    const categoryId = this.productForm.get('categoryId')?.value;
    const modelId = this.productForm.get('modelId')?.value;
    
    if (!categoryId || !modelId) return [];
    
    const categoryName = this.getCategoryName(categoryId);
    const modelName = this.getModelName(modelId);
    
    // Generate suggestions
    const suggestions: string[] = [];
    
    // Mining-specific suggestions
    const hashRates = ['90TH/s', '100TH/s', '110TH/s', '120TH/s'];
    const editions = ['Pro', 'Plus', 'Standard', 'Elite'];
    const variants = ['v1', 'v2', 'Gen 2', 'Gen 3'];
    
    // Generate combinations
    hashRates.forEach(rate => {
      suggestions.push(`${modelName} ${rate}`);
    });
    
    editions.forEach(edition => {
      suggestions.push(`${modelName} ${edition}`);
    });
    
    variants.forEach(variant => {
      suggestions.push(`${modelName} ${variant}`);
    });
    
    // Return first 6 suggestions
    return suggestions.slice(0, 6);
  }

  /**
   * Apply suggestion to product name
   */
  applySuggestion(suggestion: string) {
    this.productForm.patchValue({ name: suggestion });
  }

  /**
   * Get full product name with Category - Model - CustomName format
   */
  getFullProductName(): string {
    const categoryId = this.productForm.get('categoryId')?.value;
    const modelId = this.productForm.get('modelId')?.value;
    const customName = this.productForm.get('name')?.value;
    
    if (!categoryId || !modelId || !customName) {
      return '';
    }
    
    const categoryName = this.getCategoryName(categoryId);
    const modelName = this.getModelName(modelId);
    
    return `${categoryName} - ${modelName} - ${customName}`;
  }

  /**
   * Tag management methods - using Tag collection from database
   */
  get currentTags(): string[] {
    return this.productForm.get('tags')?.value || [];
  }

  toggleTag(tagSlug: string) {
    const currentTags = this.currentTags;
    const index = currentTags.indexOf(tagSlug);
    
    if (index > -1) {
      // Remove tag
      this.productForm.patchValue({
        tags: currentTags.filter(t => t !== tagSlug)
      });
    } else {
      // Add tag
      this.productForm.patchValue({
        tags: [...currentTags, tagSlug]
      });
    }
  }

  isTagSelected(tagSlug: string): boolean {
    return this.currentTags.includes(tagSlug);
  }

  getTagName(tagSlug: string): string {
    const tag = this.tags.find(t => t.slug === tagSlug);
    return tag?.name || tagSlug;
  }

  getTagColor(tagSlug: string): string {
    const tag = this.tags.find(t => t.slug === tagSlug);
    return tag?.color || '#F7931A';
  }

  get activeTags(): Tag[] {
    return this.tags.filter(t => t.active !== false);
  }

  /**
   * Format Firestore Timestamp to readable date string
   */
  formatTimestamp(timestamp: any): string {
    if (!timestamp) {
      return '‚Äî';
    }
    
    try {
      // Handle Firestore Timestamp
      let date: Date;
      
      if (timestamp.toDate && typeof timestamp.toDate === 'function') {
        // Firestore Timestamp object
        date = timestamp.toDate();
      } else if (timestamp.seconds !== undefined && timestamp.nanoseconds !== undefined) {
        // Firestore Timestamp-like object (from Firestore data)
        date = new Date(timestamp.seconds * 1000);
      } else if (timestamp instanceof Date) {
        // Already a Date object
        date = timestamp;
      } else if (typeof timestamp === 'number') {
        // Unix timestamp in milliseconds
        date = new Date(timestamp);
      } else if (typeof timestamp === 'string') {
        // ISO string or date string
        date = new Date(timestamp);
      } else {
        console.error('formatTimestamp: Unknown timestamp format:', timestamp);
        return 'Invalid Date';
      }
      
      // Check if date is valid
      if (isNaN(date.getTime())) {
        console.error('formatTimestamp: Invalid date created from:', timestamp);
        return 'Invalid Date';
      }
      
      const now = new Date();
      const diffMs = now.getTime() - date.getTime();
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      // Less than 1 hour ago
      if (diffMins < 60) {
        return diffMins <= 1 ? 'Just now' : `${diffMins}m ago`;
      }
      // Less than 24 hours ago
      if (diffHours < 24) {
        return `${diffHours}h ago`;
      }
      // Less than 7 days ago
      if (diffDays < 7) {
        return `${diffDays}d ago`;
      }
      // Format as date
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
      });
    } catch (error) {
      console.error('Error formatting timestamp:', error, 'Input:', timestamp);
      return 'Error';
    }
  }
}
